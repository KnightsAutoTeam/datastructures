\chapter{Balanced Binary Search Trees}


In the previous chapter, we saw how to implement a Mapping using a BST.
However, in the analysis of the main operations, it was clear that the running time of all the basic operations depended on the height of the tree.


A BST with $n$ nodes can have height $n-1$.
It's easy to get such a tree, just insert the keys in sorted order.
On the other hand, there always exists a BST with height $O(\log n)$ for any set of $n$ keys.
This is achieved by inserting the median first, followed by the medians of each half and so on recursively.
So, we have a big gap between the best case and the worst case.
Our goal will be to get as close as possible to the best case while keeping the running times of all operations proportional to the height of the tree.


We will say that a BST with $n$ nodes is \textbf{balanced} if the height of the tree is at most some constant times $\log n$.
To balance our BSTs, we want to avoid rebuilding the whole tree.
Instead, we'd like to make a minimal change to the tree that will preserve the BST property.


The most basic such operation is called a \textbf{tree rotation}.
It comes in two forms, \texttt{rotateright} and \texttt{rotateleft}.
Rotating a node to the right will move it to be the right child of its left child and will update the children of these nodes appropriately.
Here it is in code.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{rotateright}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n}{newroot}\PY{o}{.}\PY{n}{right}
    \PY{n}{newroot}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}
    \PY{k}{return} \PY{n}{newroot}
\end{Verbatim}



Notice that \texttt{rotateright} returns the new root (of the subtree).
This is a very useful convention when working with BSTs and rotations.
Every method that can change the structure of the tree will return the new root of the resulting subtree.
Thus, calling such methods will always be combined with an assignment.
For example, if we want to rotate the left child of a node \texttt{parent} to the right, we would write \texttt{parent.left = parent.left.rotateright()}.

\section{A \texttt{BSTMapping} implementation}


Here is the code for the \texttt{BSTMapping} that implements rotations.
We make sure to also update the lengths after each rotation.
The main difference with our previous code is that now, all methods that can change the tree structure are combined with assignments.
It is assumed that only \texttt{put} and \texttt{remove} will rearrange the tree, and so \texttt{get} and \texttt{floor} will keep the tree structure as is.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{orderedmapping} \PY{k+kn}{import} \PY{n}{BSTMapping}\PY{p}{,} \PY{n}{BSTNode}

\PY{k}{class} \PY{n+nc}{BalancedBSTNode}\PY{p}{(}\PY{n}{BSTNode}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newnode}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{BalancedBSTNode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{key} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
        \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newnode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newnode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{k}{return} \PY{n+nb+bp}{self}

    \PY{k}{def} \PY{n+nf}{rotateright}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n}{newroot}\PY{o}{.}\PY{n}{right}
        \PY{n}{newroot}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{n}{newroot}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{rotateleft}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n}{newroot}\PY{o}{.}\PY{n}{left}
        \PY{n}{newroot}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{n}{newroot}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}

\PY{k}{class} \PY{n+nc}{BalancedBST}\PY{p}{(}\PY{n}{BSTMapping}\PY{p}{)}\PY{p}{:}
    \PY{n}{Node} \PY{o}{=} \PY{n}{BalancedBSTNode}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{Node}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
\end{Verbatim}


\subsection{Forward Compatibility of Factories}


We are looking into the future a little with this code.
In particular, we want this class to be easily extendable.
To do this, we don't create new instances of the nodes directly.
In the \texttt{BSTMapping} class, we have the assignment \texttt{Node = BSTNode} and create new nodes by writing \texttt{self.Node(key, value)} rather than \texttt{BSTNode(key, value)}.
This way, when we extend this class (as we will several times), we can use a different value for \texttt{Node} in order to produce different types of nodes without having to rewrite all the methods from \texttt{BSTMapping}.
Similarly, we use a \texttt{newnode} method in the \texttt{BSTNode} class.
A method that generates new instances of a class is sometimes called a \textbf{factory}.


With regards to \emph{forward compatibility}, it's a challenge to walk the fine line between, good design and premature optimization.
In our case, the use of a factory to generate nodes only came about after the need was clear from writing subclasses.
This should be a general warning to students when reading code in textbooks.
One often only sees how the code ended up, but not how it started.
It's helpful to ask, "Why is the code written this way or that way?", but the answer might be that it will make later code easier to write.

\section{Weight Balanced Trees}


Now, we're ready to balance our trees.
One way to be sure the tree is balanced is to have the key at each node \texttt{x} be the median of all the keys in the subtree at \texttt{x}.
Then, the situation would be analogous to binary search in a sorted \texttt{list}.
Moving down the tree, every node would have have as many nodes in its subtree than its parent.
Thus, after $\log n$ steps, we reach a leaf and so the BST would be balanced.


Having medians in every node a nice ideal to have, but it is both too difficult to achieve and too strong an invariant for balancing BSTs.
Recall that in our analysis of \texttt{quicksort} and \texttt{quickselect}, we considered \emph{good pivots} to be those that lay in the middle half of the list (i.e. those with rank between $n/4$ and $3n/4$).
If the key in each node is a good pivot among the keys in its subtree, then we can also guarantee an overall height of $\log_{4/3} n$.


We'll say a node \texttt{x} is \textbf{weight-balanced} if


\texttt{len(x) + 1 < 4 * (min(len(x.left), len(x.right)) +  1)}.


It's easy enough to check this condition with our \texttt{BSTMapping} implementation because it keeps track of the length at each node.
If some change causes a node to no longer be weight balanced, we will recover the weight balance by rotations.
In the easiest case, a single rotation suffices.
If one is rotation is not enough, then two rotations will be enough.
We'll have to see some examples and do some simple algebra to see why.


The \texttt{rebalance} method will check for the balance condition and do the appropriate rotations.
We'll call this method after every change to the tree, so we can assume that the unbalanced node \texttt{x} is only just barely imbalanced.
Without loss of generality, let's assume \texttt{x} has too few nodes in its left subtree.
Then, when we call \texttt{x.rotateleft()}, we have to check that both \texttt{x} becomes weight balanced and also that its new parent \texttt{y} (the former right child of \texttt{x}) is weight balanced.
Clearly, \texttt{len(x) == len(x.rotateleft())} as both contain the same nodes.
So, there is an imbalance at \texttt{y} after the rotation only if its right child is too light.
In that case, we rotate \texttt{y} right before rotating \texttt{x} left.
This will guarantee that all the nodes in the subtree are weight balanced.


This description is not enough to be convincing that the algorithm is correct, but it is enough to write code.
Let's look at the code first and see the rebalance method in action.
Then, we'll go back and do the algebra to prove it is correct.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{orderedmapping} \PY{k+kn}{import} \PY{n}{BalancedBST}\PY{p}{,} \PY{n}{BalancedBSTNode}

\PY{k}{class} \PY{n+nc}{WBTreeNode}\PY{p}{(}\PY{n}{BalancedBSTNode}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newnode}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{WBTreeNode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{toolight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{other}\PY{p}{)}\PY{p}{:}
        \PY{n}{otherlength} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{other}\PY{p}{)} \PY{k}{if} \PY{n}{other} \PY{k}{else} \PY{l+m+mi}{0}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{4} \PY{o}{*} \PY{p}{(}\PY{n}{otherlength} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{rebalance}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{toolight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{toolight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{right}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
            \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
        \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{toolight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{toolight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{left}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
            \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}
        \PY{k}{return} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}\PY{o}{.}\PY{n}{rebalance}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{remove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}\PY{o}{.}\PY{n}{rebalance}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{newroot} \PY{k}{else} \PY{k+kc}{None}

\PY{k}{class} \PY{n+nc}{WBTree}\PY{p}{(}\PY{n}{BalancedBST}\PY{p}{)}\PY{p}{:}
    \PY{n}{Node} \PY{o}{=} \PY{n}{WBTreeNode}
\end{Verbatim}



The \texttt{toolight} method is for checking if a subtree has enough nodes to be a child of a weight balanced node.
We use it both to check if the current node is weight balanced and also to check if one rotation or two will be required.


The \texttt{put} and \texttt{remove} methods call the corresponding methods from the superclass \texttt{BSTNode} and then rebalance before returning.
We tried to reuse as much as possible our existing implementation.

\section{Height-Balanced Trees (AVL Trees)}


The motivation for balancing our BSTs was to keep the height small.
Rather than balancing by weight, we could also try to keep the heights of the left and right subtrees close.
In fact, we can require that these heights differ by at most one.
Similar to weight balanced trees, we'll see if the height balanced property is violated and if so, fix it with one or two rotations.


Such height balanced trees are often called AVL trees.
In our implementation, we'll maintain the height of each subtree and use these to check for balance.
Often, AVL trees only keep the balance at each node rather than the exact height, but computing heights is relatively painless.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{orderedmapping} \PY{k+kn}{import} \PY{n}{BalancedBST}\PY{p}{,} \PY{n}{BalancedBSTNode}

\PY{k}{def} \PY{n+nf}{height}\PY{p}{(}\PY{n}{node}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{node}\PY{o}{.}\PY{n}{height} \PY{k}{if} \PY{n}{node} \PY{k}{else} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}

\PY{k}{def} \PY{n+nf}{update}\PY{p}{(}\PY{n}{node}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{node}\PY{p}{:}
        \PY{n}{node}\PY{o}{.}\PY{n}{\PYZus{}updatelength}\PY{p}{(}\PY{p}{)}
        \PY{n}{node}\PY{o}{.}\PY{n}{\PYZus{}updateheight}\PY{p}{(}\PY{p}{)}

\PY{k}{class} \PY{n+nc}{AVLTreeNode}\PY{p}{(}\PY{n}{BalancedBSTNode}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}updateheight}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{newnode}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{AVLTreeNode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{\PYZus{}updateheight}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{height} \PY{o}{=} \PY{l+m+mi}{1} \PY{o}{+} \PY{n+nb}{max}\PY{p}{(}\PY{n}{height}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{p}{)}\PY{p}{,} \PY{n}{height}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{balance}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{height}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{height}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{rebalance}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{bal} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{balance}\PY{p}{(}\PY{p}{)}
        \PY{k}{if} \PY{n}{bal} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{balance}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
            \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
        \PY{k}{elif} \PY{n}{bal} \PY{o}{==} \PY{l+m+mi}{2}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{balance}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZlt{}} \PY{l+m+mi}{0}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
            \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}
        \PY{n}{update}\PY{p}{(}\PY{n}{newroot}\PY{o}{.}\PY{n}{left}\PY{p}{)}
        \PY{n}{update}\PY{p}{(}\PY{n}{newroot}\PY{o}{.}\PY{n}{right}\PY{p}{)}
        \PY{n}{update}\PY{p}{(}\PY{n}{newroot}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{n}{update}\PY{p}{(}\PY{n}{newroot}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}\PY{o}{.}\PY{n}{rebalance}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{remove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}
        \PY{n}{update}\PY{p}{(}\PY{n}{newroot}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}\PY{o}{.}\PY{n}{rebalance}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{newroot} \PY{k}{else} \PY{k+kc}{None}

\PY{k}{class} \PY{n+nc}{AVLTree}\PY{p}{(}\PY{n}{BalancedBST}\PY{p}{)}\PY{p}{:}
    \PY{n}{Node} \PY{o}{=} \PY{n}{AVLTreeNode}
\end{Verbatim}


\section{Splay Trees}


Let's add in one more balanced BST for good measure.
In this case, we won't actually get a guarantee that the resulting tree is balanced, but we will get some other nice properties.


In a \textbf{splay tree}, every time we get or put an entry, its node will get rotated all the way to the root.
However, instead of rotating it directly, we consider two steps at a time.
The \texttt{splayup} method looks two levels down the tree for the desired key.
If its not exactly two levels down, it does nothing.
Otherwise, it rotates it up twice.
If the rotations are in the same direction, the bottom one is done first.
If the rotations are in opposite directions, it does the top one first.


At the very top level, we may do only a single rotation to get the node all the way to the root.
This is handled by the \texttt{splayup} method in the \texttt{SplayTree} class.


A major difference from our previous implementations is that now, we will modify the tree on calls to \texttt{get}.
As a result, we will have to rewrite \texttt{get} rather than inheriting it.
Previously, get would return the desired value.
However, we want to return the new root on every operation that might change the tree.
So, which should we return?
Clearly, we need that value to return, and we also need to not break the tree.
Thankfully, there is a simple solution.
The splaying operation conveniently rotates the found node all the way to the root.
So, the \texttt{SplayTreeNode.get} method will return the new root of the subtree, and the \texttt{SplayTree.get} returns the value at the root.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{orderedmapping} \PY{k+kn}{import} \PY{n}{BalancedBST}\PY{p}{,} \PY{n}{BalancedBSTNode}

\PY{k}{class} \PY{n+nc}{SplayTreeNode}\PY{p}{(}\PY{n}{BalancedBSTNode}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newnode}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{SplayTreeNode}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{splayup}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}
        \PY{k}{if} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{k}{if} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{key}\PY{p}{:}
                \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
            \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{key}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
                \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
        \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{key}\PY{p}{:}
                \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
            \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{key}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
                \PY{n}{newroot} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{newroot} \PY{o}{=} \PY{n}{BalancedBSTNode}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{k}{return} \PY{n}{newroot}\PY{o}{.}\PY{n}{splayup}\PY{p}{(}\PY{n}{key}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{key} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}
        \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{left}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{elif} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{right}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{raise} \PY{n+ne}{KeyError}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{splayup}\PY{p}{(}\PY{n}{key}\PY{p}{)}

\PY{k}{class} \PY{n+nc}{SplayTree}\PY{p}{(}\PY{n}{BalancedBST}\PY{p}{)}\PY{p}{:}
    \PY{n}{Node} \PY{o}{=} \PY{n}{SplayTreeNode}

    \PY{k}{def} \PY{n+nf}{splayup}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{key} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{rotateright}\PY{p}{(}\PY{p}{)}
        \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{key}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{rotateleft}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:} \PY{k}{raise} \PY{n+ne}{KeyError}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{splayup}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{o}{.}\PY{n}{value}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{BalancedBST}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{splayup}\PY{p}{(}\PY{n}{key}\PY{p}{)}
\end{Verbatim}
