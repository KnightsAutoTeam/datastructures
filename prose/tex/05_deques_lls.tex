\chapter{Deques and Linked Lists}


A \textbf{deque} (pronounced "deck") is a doubly-ended queue.
It acts like both a stack and a queue, storing an ordered collection of items with the ability to add or remove from both the beginning and the end.
Here is the ADT.

\section{The Deque ADT}

\begin{itemize}

\item \textbf{addfirst(item)} - add \texttt{item} to the front of the deque.

\item \textbf{addlast(item)} - add \texttt{item} to the end of the deque.

\item \textbf{removefirst(item)} - remove and return the first item in the deque.

\item \textbf{removelast(item)} - remove and return the last item in the deque.

\item \textbf{len} - return the number of items in the deque.

\end{itemize}

As a start, let's see what a deque implementation would look like using a list.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{ListDeque}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{addfirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{insert}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{item}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{addlast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{item}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{removefirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{removelast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{p}{)}
\end{Verbatim}



The code is simple enough, but a couple of operations will start to get slow as the deque gets large.
Inserting and popping at index $0$ takes $O(n)$ time.
This follows from the way lists are stored sequentially in memory.
There is no way to change the beginning of the list without shifting all the other elements to make room or fill gaps.
To make this work, we are going to have to give up on the idea of having the items laid out sequentially in memory.
Instead, we'll store some more information with each item that we can use to extract the order.

\section{Linked Lists}


Linked lists are a simple data structure for storing a sequential collection.
Unlike a standard python list, it will allow us to insert at the beginning quickly.
The idea is to store the items in individual objects called \textbf{nodes}.
A special node is the head of the list.
Each node stores a reference to the next node in the list.


We will use the usual trick of looking back into our intuitive description above to find the nouns that will be the types we will need to define.
In this case, there is the list itself and the nodes.
Let's write a class for a \texttt{ListNode}.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{ListNode}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{data}\PY{p}{,} \PY{n}{link} \PY{o}{=} \PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{data} \PY{o}{=} \PY{n}{data}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{n}{link}
\end{Verbatim}



Now, to start the \texttt{LinkedList}, we will store the head of the list.
We will provide two methods, \texttt{addfirst} and \texttt{removefirst} both of which modify the beginning of the list.
These will behave roughly like the push and pop operations of the stack.
This first implementation will hide the nodes from the user.
That is, from a users perspective, they can create a linked list, and they can add and remove nodes, but they don't have to touch (or even know about) the nodes.
This is abstraction (hiding details)!

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{LinkedList}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{k+kc}{None}

    \PY{k}{def} \PY{n+nf}{addfirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{removefirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{data}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{link}
        \PY{k}{return} \PY{n}{item}
\end{Verbatim}


\section{Implementing a Queue with a LinkedList}


Recall that even our best list implementation of a Queue required linear time in the worst case for \texttt{dequeue} operations (though constant on average).
We could hope to do better with a linked list.
However, right now, we have no way to add to or remove from the end of the linked list.
Here is an inefficient, though simple and correct way to do it.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{LinkedList}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{k+kc}{None}

    \PY{k}{def} \PY{n+nf}{addfirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{addlast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{addfirst}\PY{p}{(}\PY{n}{item}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{currentnode} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}
            \PY{k}{while} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
                \PY{n}{currentnode} \PY{o}{=} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link}
            \PY{n}{currentnode}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{removefirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{data}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{link}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{removelast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{link} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{removefirst}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{currentnode} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}
            \PY{k}{while} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link}\PY{o}{.}\PY{n}{link} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
                \PY{n}{currentnode} \PY{o}{=} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link}
            \PY{n}{currentnode}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{k+kc}{None}
            \PY{k}{return} \PY{n}{currentnode}\PY{o}{.}\PY{n}{data}
\end{Verbatim}



The new \texttt{addlast} method implements a very common pattern in linked lists.
It starts at the head of the linked list and \textbf{traverses} to the end by following the \texttt{link}s.
It uses the convention that the \texttt{link} of the last node is \texttt{None}.


Similarly, \texttt{removelast} traverses the list until it reaches the second to last element.


This traversal approach is not very efficient.
For a list of length $n$, we would need $O(n)$ time to find the end.


A different approach might be to store the last node (or \textbf{tail}) of the list so we don't have to search for it when we need it.
This requires a bit of overhead to make sure it always stores the correct node.
Most of the special cases happen when there is only one item in the list.
We will be able to use this to get some improvement for \texttt{addlast}, because we will be able to jump right to the end without traversing.  We will also be able to clean up the code for \texttt{removelast} a little by eliminating the \texttt{link.link} stuff and instead just check if we reached the tail.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{LinkedList}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{k+kc}{None}

    \PY{k}{def} \PY{n+nf}{addfirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{p}{)}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}

    \PY{k}{def} \PY{n+nf}{addlast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{item}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link}

    \PY{k}{def} \PY{n+nf}{removefirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{data}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{link}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{k+kc}{None}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{removelast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{removefirst}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{currentnode} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}
            \PY{k}{while} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{p}{:}
                \PY{n}{currentnode} \PY{o}{=} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link}
            \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{data}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n}{currentnode}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{k+kc}{None}
            \PY{k}{return} \PY{n}{item}
\end{Verbatim}



Now we can implement the Queue ADT with a linked list.
It will be surprisingly easy.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} linkedqueue.py}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{deque} \PY{k+kn}{import} \PY{n}{LinkedList}

\PY{k}{class} \PY{n+nc}{LinkedQueue}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L} \PY{o}{=} \PY{n}{LinkedList}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{enqueue}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{addlast}\PY{p}{(}\PY{n}{item}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{dequeue}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{removefirst}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{peek}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{removefirst}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{o}{.}\PY{n}{addfirst}\PY{p}{(}\PY{n}{item}\PY{p}{)}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}L}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{isempty}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}
\end{Verbatim}


\section{Storing the length}


With our \texttt{ListQueue}, we implemented \texttt{\_\_len\_\_} to give the number of items in the queue.
To implement the same method on the \texttt{LinkedQueue}, we will want \textbf{delegate} the length computation to the \texttt{LinkedList}.


Let's add the ability to get the length of the linked list.
We'll do it by storing the length and updating it with each operation.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{LinkedList}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{=} \PY{l+m+mi}{0}

    \PY{k}{def} \PY{n+nf}{addfirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{p}{)}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}

    \PY{k}{def} \PY{n+nf}{addlast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{addfirst}\PY{p}{(}\PY{n}{item}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{n}{ListNode}\PY{p}{(}\PY{n}{item}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}

    \PY{k}{def} \PY{n+nf}{removefirst}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{data}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}\PY{o}{.}\PY{n}{link}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{removelast}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{p}{:}
            \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{removefirst}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{currentnode} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}head}
            \PY{k}{while} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{p}{:}
                \PY{n}{currentnode} \PY{o}{=} \PY{n}{currentnode}\PY{o}{.}\PY{n}{link}
            \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{data}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail} \PY{o}{=} \PY{n}{currentnode}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}tail}\PY{o}{.}\PY{n}{link} \PY{o}{=} \PY{k+kc}{None}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length}
\end{Verbatim}



We still have to iterate through the whole list in order to remove from the end.
It seems very hard to avoid this.
As a result, our \texttt{removelast} method still takes linear time.
We won't fix this until the next chapter and it will require a new idea.
So, instead of testing the deque ADT methods now, we'll instead see how to implement an efficient queue using a linked list.

\section{Testing Against the ADT}


Recall that the Queue ADT specifies the expected behavior of a Queue data structure.
It describes the \textbf{public interface} to the class.
Now that we can use our \texttt{LinkedList} class to implement a Queue with worst-case constant time operations, we have multiple distinct implementations of the ADT.
Good tests for these data structures would only assume that they implement what is provided in the ADT.
In fact, we probably want to test both implementations with the same tests.


If we rename our first Queue implementations \texttt{ListQueue}, we might have had the following tests for it.


\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{unittest}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{queue} \PY{k+kn}{import} \PY{n}{ListQueue}

\PY{k}{class} \PY{n+nc}{TestListQueue}\PY{p}{(}\PY{n}{unittest}\PY{o}{.}\PY{n}{TestCase}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{testinit}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testaddandremoveoneitem}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}
        \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testalternatingaddremove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{i}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testmanyoperations}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{l+m+mi}{2} \PY{o}{*} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{3}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{3}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testlength}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}

\PY{k}{if} \PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}main\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
    \PY{n}{unittest}\PY{o}{.}\PY{n}{main}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

\begin{Verbatim}

.....
----------------------------------------------------------------------
Ran 5 tests in 0.004s

OK

\end{Verbatim}


Now that we have another implementation, we might be tempted to just copy and paste the old tests, changing the references from \texttt{ListQueue} to \texttt{LinkedQueue}.
That is a lot of code duplication and code duplication leads to problems.
For example, suppose we realize that our code has issues if we try to \texttt{dequeue} from an empty queue.
If we decide on the right behavior, we will enforce it with a test.
Do we also copy the test to the other (copied) test file?
What if one implementation is fixed and the other is not?


This is a standard situation where inheritance is called for.
We wanted to copy a bunch of methods to be included in two different classes (\texttt{TestListQueue} and \texttt{TestLinkedQueue}).
Instead we want them to \emph{share} the methods.
So, we \textbf{refactor} the code, by \textbf{extracting a superclass}.
Our new class will be called \texttt{TestQueue}.
Both \texttt{TestListQueue} and \texttt{TestLinkedQueue} will extend \texttt{TestQueue}.
Remember extending means inheriting from.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} testqueue.py}
\PY{k}{class} \PY{n+nc}{TestQueue}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newQueue}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n+ne}{NotImplementedError}

    \PY{k}{def} \PY{n+nf}{testinit}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newQueue}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testaddandremoveoneitem}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newQueue}\PY{p}{(}\PY{p}{)}
        \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testalternatingaddremove}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newQueue}\PY{p}{(}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{i}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testmanyoperations}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newQueue}\PY{p}{(}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{l+m+mi}{2} \PY{o}{*} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{3}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{3}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{testlength}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n}{q} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{newQueue}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{enqueue}\PY{p}{(}\PY{n}{i}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{:}
            \PY{n}{q}\PY{o}{.}\PY{n}{dequeue}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{assertEqual}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{q}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}



The new class looks almost exactly the same as our old \texttt{TestListQueue} class exactly for a couple small changes.
Instead of creating a new \texttt{ListQueue} object in each test, we call a method called \texttt{newQueue}.
In this class, that method is \emph{not implemented} and you can see it will raise an error telling you so if you were to try to call it.
This method will be overwritten in the extending class to provide the right kind of Queue object.
There is another \emph{important difference} between the \texttt{TestQueue} class and our old \texttt{TestListQueue} class---the \texttt{TestQueue} class does not extend \texttt{unittest.TestCase}.
It just defines some methods that will be \textbf{mixed into} \texttt{TestListQueue} and \texttt{TestLinkedQueue}.
Here are our new test files.


\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} testlistqueue.py}
\PY{k+kn}{import} \PY{n+nn}{unittest}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{testqueue} \PY{k+kn}{import} \PY{n}{TestQueue}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{queue} \PY{k+kn}{import} \PY{n}{ListQueue}

\PY{k}{class} \PY{n+nc}{TestListQueue}\PY{p}{(}\PY{n}{unittest}\PY{o}{.}\PY{n}{TestCase}\PY{p}{,} \PY{n}{TestQueue}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newQueue}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{ListQueue}\PY{p}{(}\PY{p}{)}

\PY{k}{if} \PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}main\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
    \PY{n}{unittest}\PY{o}{.}\PY{n}{main}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

\begin{Verbatim}

Traceback (most recent call last):
  File "ton67a7syl", line 3, in <module>
    from ds2.testqueue import TestQueue
ModuleNotFoundError: No module named 'ds2.testqueue'

\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} testlinkedqueue.py}
\PY{k+kn}{import} \PY{n+nn}{unittest}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{testqueue} \PY{k+kn}{import} \PY{n}{TestQueue}
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{queue} \PY{k+kn}{import} \PY{n}{LinkedQueue}

\PY{k}{class} \PY{n+nc}{TestListQueue}\PY{p}{(}\PY{n}{unittest}\PY{o}{.}\PY{n}{TestCase}\PY{p}{,} \PY{n}{TestQueue}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{newQueue}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{LinkedQueue}\PY{p}{(}\PY{p}{)}

\PY{k}{if} \PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}main\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
    \PY{n}{unittest}\PY{o}{.}\PY{n}{main}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

\begin{Verbatim}

\end{Verbatim}


The classes, \texttt{TestListQueue} and \texttt{TestLinkedQueue}, extend both \texttt{unittest.TestCase} \emph{and} \texttt{TestQueue}.
This is called \textbf{multiple inheritance}.
In other languages like C++ that support multiple inheritance, it is considered a bad design decision.
However, in python, it is appropriate to use it for this kind of \textbf{mix in}.
The only thing to remember is that the golden rule of inheritance should still be observed: \textbf{inheritance mean 'is a'}.

\section{The Main Lessons:}

\begin{itemize}

\item Use the public interface as described in an ADT to \textbf{test} your class.

\item You can use \textbf{inheritance} to share functionality between classes.

\item Inheritance means \textbf{'is a'}.

\end{itemize}
\section{Design Patterns:  The Wrapper Pattern}


In the last two chapters, we saw several different implementations of the Queue ADT.
The main ones, \texttt{LinkedQueue} and \texttt{ListQueue} were very simple.
In both cases, we used \textbf{composition}, the class stored an object of another class, and then \textbf{delegates} most of the operations to the other class.
These are examples of something called the \textbf{Wrapper Pattern}.
The Queue in both cases is a wrapper around another data structure.


\textbf{Design patterns} also known as \textbf{object-oriented design patterns} or simply \textbf{patterns} are ways of organizing classes in to solve common programming problems.
In the case of the Wrapper Pattern, we have a class that already "sort of" does what we want, but it has different names for the operations and it possibly has many other operations that we don't want to support.
So, we create a new class that \textbf{has an} instance of another class (a \texttt{list} or \texttt{LinkedList} in our example) and then provide methods that operate on that object.
From outside the class, we don't have to know anything about the wrapped class.
Sometimes, this separation is called a \textbf{layer of abstraction}.
The user of our class does not have to know anything about our implementation in order to use the class.

\section{The Main Lessons:}

\begin{itemize}

\item Use design patterns where appropriate to organize your code and improve readability.

\item The Wrapper Pattern gives a way to provide an alternative interface to (a subset of) the methods in another class.

\item Composition means \textbf{'has a'}.

\end{itemize}