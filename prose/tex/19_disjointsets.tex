\chapter{(Disjoint) Sets}


The chapter on mappings explains how we might hope to get constant time operations for many set operations.
It also makes clear why one cannot create a set of sets in python (at least, not directly).
The elements of a set must be hashable because they are stored in a hash table.
If you have sets that will not change, you can use the immutable \texttt{frozenset} data structure to store the sets and achieve many of of the benefits of \texttt{set}, while also being hashable.


However, there is one common data structuring problem that requires us to store a collection of sets that can change.
It is called the \textbf{Disjoint Sets} problem.
In this problem, we have a collection of things and the things are grouped in to disjoint sets.
We'd like to be able to quickly \emph{find} if two things are in the same group.
On the other hand, we are sometimes \emph{told} that two things are in the same group, in which case, we may need change our idea of the grouping, combining two groups into one.


A data structure to store a collection of disjoint sets is often called a \textbf{Union-Find} data structure, because it supports operations called, you guessed it, \texttt{union} and \texttt{find}.

\section{The Disjoint Sets ADT}

\begin{itemize}

\item 

\textbf{\texttt{union(a, b)}} Replace the sets containing \texttt{a} and \texttt{b} with a single set that is their union.



\item 

\textbf{\texttt{find(a, b)}} Return \texttt{True} is \texttt{a} and \texttt{b} are in the same set.  Otherwise, return \texttt{False}.



\end{itemize}
\section{A Simple Implementation}


A very straightforward approach is to store the sets and a mapping that identifies each item with the set that contains it.
Because the sets are disjoint, there is a unique set that contains each item, so a mapping is appropriate.
The sets are the values in the mapping (not the keys), so there is no need for the sets to be hashable.
Here is an implementation.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{DisjointSetsMapping}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}map} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{item}\PY{p}{\PYZcb{}} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}map}\PY{p}{[}\PY{n}{b}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{n}{union} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}map}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{|} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}map}\PY{p}{[}\PY{n}{b}\PY{p}{]}
            \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{union}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}map}\PY{p}{[}\PY{n}{item}\PY{p}{]} \PY{o}{=} \PY{n}{union}
\end{Verbatim}



Here's a different idea.
We could just label the items.
If two items have the same label, then they are in the same set.
Union just relabels the items in one of the sets.
In this way, the sets themselves are implicit.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{DisjointSetsLabels}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{p}{[}\PY{n}{b}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{k}{if} \PY{n}{value} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{p}{[}\PY{n}{b}\PY{p}{]}\PY{p}{:}
                    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}label}\PY{p}{[}\PY{n}{a}\PY{p}{]}
\end{Verbatim}



Maybe this implementation is worse in some ways. It has to iterate through all the labels rather than just the subset that are connected. It does have the advantage that it does away with all the set operations in union. Again, this may not be better.
We can try to make our union operation much faster by changing fewer labels. In the next one, we will do this. Instead of mapping items to labels, we map them to an item that we'll call its parent. If every node has a single parent and there are no loops, then we get a forest. It is a collection of trees.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{DisjointSetsForest}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{:}
            \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}



Is this much better? In many cases, it probably is, but not necessarily. I can easily construct an example where this code will take a long time. For example, I could force the forest to be a path. Then, calling the \texttt{\_root} method can take time proportional to the number of items. If we're going to improve our worst-case running time, then we'll improve on those examples. We'll have to keep the paths short if possible.

\chapter{Path Compression}


If we want to avoid traversing long paths to many times, we can just go and make them shorter each time we traverse them.  A simple way to do this is just to replace parents with gradnparents as we go up the tree.  This only requires one more line of code.  The affect is that the depth of every node on the path we traverse gets cut in half (plus one).  This means that the longest path can only get traversed $O(log n)$ times before it is compressed down to a single edge.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Path Compression halving as we go.  }
\PY{c+c1}{\PYZsh{} Every node on the path to root is updated to point to its grandparent.}
\PY{k}{class} \PY{n+nc}{DisjointSetsPathCompression}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{:}
            \PY{n}{parent} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}
            \PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]} \PY{o}{=} \PY{n}{parent}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{parent}\PY{p}{]}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}



Without too much more effort, we can \emph{really} compress paths to the root by making a second pass.
In the first pass, we just find the root.  In the second pass, we update all the parents to point to the root.
Here is the updated code.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Path compression with two passes.}
\PY{c+c1}{\PYZsh{} Retraverse the path to the root, pointing every node all the way up to the new root.}
\PY{k}{class} \PY{n+nc}{DisjointSetsTwoPassPC}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n}{root} \PY{o}{=} \PY{n}{item}
        \PY{k}{while} \PY{n}{root} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{root}\PY{p}{]}\PY{p}{:}
            \PY{n}{root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{root}\PY{p}{]}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}compress}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n}{root}\PY{p}{)}
        \PY{k}{return} \PY{n}{root}

    \PY{k}{def} \PY{n+nf}{\PYZus{}compress}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{,} \PY{n}{newroot}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n}{newroot}\PY{p}{:}
            \PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{,} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}



If you are really trying to optimize this, you may squeeze a little improvement by removing the redundancy involved in calling \texttt{\_root} twice for each item in the \texttt{union} method (once in \texttt{find} and again in the \texttt{if} statement).

\chapter{Merge by Height}


Another way you might try to keep paths short is to be just a little more careful about who gets to be the new root when doing a \texttt{union} operation.  The taller tree should be the new root, Then, the height will not increase unless you are merging two trees of the same height.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Merge by height}
\PY{k}{class} \PY{n+nc}{DisjointSetsMergeByHeight}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{l+m+mi}{0} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{:}
            \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height}\PY{p}{[}\PY{n}{b}\PY{p}{]}\PY{p}{:}
                \PY{n}{a}\PY{p}{,}\PY{n}{b} \PY{o}{=} \PY{n}{b}\PY{p}{,}\PY{n}{a}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height}\PY{p}{[}\PY{n}{a}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}height}\PY{p}{[}\PY{n}{b}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\chapter{Merge By Weight}


Instead of looking at the heights of the trees, one could look at the number of nodes in the trees.  If one tree has more nodes, \emph{maybe} it is also taller.  The advantage over merge by height is that this information is not affected by path compression.  Therefore we can (and will soon) combine these tricks.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Merge by weight}
\PY{k}{class} \PY{n+nc}{DisjointSetsMergeByWeight}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{l+m+mi}{1} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{:}
            \PY{n}{item} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}
        \PY{k}{return} \PY{n}{item}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{b}\PY{p}{]}\PY{p}{:}
                \PY{n}{a}\PY{p}{,}\PY{n}{b} \PY{o}{=} \PY{n}{b}\PY{p}{,}\PY{n}{a}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{+}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{b}\PY{p}{]}
\end{Verbatim}


\chapter{Combining Heuristics}


As mentioned before, we can use both heuristics, combining merge by weight and path compression.  it turns out that this is very efficient, both in theory and in practice.  The running time of $n$ operations is (as close as you will ever be able to tell) proportional to $n$.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Merge by weight and path compression}
\PY{k}{class} \PY{n+nc}{DisjointSets}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{L}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{n}{item} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{item} \PY{p}{:} \PY{l+m+mi}{1} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{L}\PY{p}{\PYZcb{}}

    \PY{k}{def} \PY{n+nf}{\PYZus{}root}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{)}\PY{p}{:}
        \PY{n}{root} \PY{o}{=} \PY{n}{item}
        \PY{k}{while} \PY{n}{root} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{root}\PY{p}{]}\PY{p}{:}
            \PY{n}{root} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{root}\PY{p}{]}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}compress}\PY{p}{(}\PY{n}{item}\PY{p}{,} \PY{n}{root}\PY{p}{)}
        \PY{k}{return} \PY{n}{root}

    \PY{k}{def} \PY{n+nf}{\PYZus{}compress}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{item}\PY{p}{,} \PY{n}{newroot}\PY{p}{)}\PY{p}{:}
        \PY{k}{while} \PY{n}{item} \PY{o+ow}{is} \PY{o+ow}{not} \PY{n}{newroot}\PY{p}{:}
            \PY{n}{item}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{,} \PY{n}{newroot}

    \PY{k}{def} \PY{n+nf}{find}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)} \PY{o+ow}{is} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{union}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{o+ow}{not} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{find}\PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{b}\PY{p}{]}\PY{p}{:}
                \PY{n}{a}\PY{p}{,}\PY{n}{b} \PY{o}{=} \PY{n}{b}\PY{p}{,}\PY{n}{a}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}parent}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}root}\PY{p}{(}\PY{n}{a}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{a}\PY{p}{]} \PY{o}{+}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}weight}\PY{p}{[}\PY{n}{b}\PY{p}{]}
\end{Verbatim}
